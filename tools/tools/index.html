<!doctype html>
<html>
  <head>
    <title></title>
    <link rel="stylesheet" href="../vendors/bootstrap/css/bootstrap.min.css" type="text/css" media="screen" charset="utf-8" />
    <link rel="stylesheet" href="../vendors/font-awesome-4.4.0/css/font-awesome.min.css" type="text/css" media="screen" charset="utf-8" />
    <script src="../vendors/d3.min.js"></script>
    <script src="../vendors/underscore.min.js"></script>
    <script src="../vendors/jquery.min.js"></script>
    <script src="../vendors/bootstrap/js/bootstrap.min.js"></script>
    <style>
      #tree {
        height: 300px;
        min-height: 300px;
      }
      #out {
        height: 300px;
      }
      #tests {
        height: 300px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1></h1>

      <div class="row">
        <div class="col-sm-4">
          <input type="text" class="form-control" placeholder="Test name" />
        </div>
      </div>

      <div class="row">
        <div class="col-sm-4">
          <label>Svg</label>
          <svg id="tree" class="form-control"></svg>
          <div class="">
            <button class="btn btn-default" onclick="setMode('commits')"><i class="fa fa-circle"></i></button>
            <button class="btn btn-default" onclick="setMode('links')"><i class="fa fa-share-alt"></i></button>
            <button class="btn btn-default" onclick="btnAddRowClicked()"><i class="fa fa-plus"></i> Add row</button>
            <button class="btn btn-default">Add column</button>
          </div>
        </div>
        <div class="col-sm-4">
          <label>Input file</label>
          <textarea id="out" class="form-control" readonly></textarea>
        </div>
        <div class="col-sm-4">
          <label>Tests file</label>
          <textarea id="tests" class="form-control" readonly></textarea>
        </div>
      </div>
    </div>
    <script>
      var mode = 'commits';
      var firstCommit = null;

      var setMode = function(modeName) {
        mode = modeName;
        render();
      };

      var tree = [];

      var btnAddRowClicked = function() {
        tree.push({id: tree.length.toString(), parents: []});
        render();
      };


      var lineFunction = d3.svg.line()
        .x(function(d) { return d.x; })
        .y(function(d) { return d.y; })
        .interpolate("linear");


      var render = function() {
        var xGap = 30;
        var yGap = 30;
        var cols = 10;
        var radius = 8;

        var svg = d3.select($('#tree')[0]);
        svg.style('height', (tree.length + 1) * yGap + radius);
        svg.selectAll('*').remove();

        var linesGroup = svg.append('g');

        var lineGroup = linesGroup.selectAll('lines')
          .data(tree)
          .enter()
          .append('g');

        lineGroup
          .append('path')
          .attr('d', function(path, idx) {
            var d = [];
            d.push({x: 0, y: idx * yGap + yGap});
            d.push({x: $('#tree').width(), y: idx * yGap + yGap});
            return lineFunction(d)
          })
          .attr('stroke-width', 1)
          .attr('fill', 'none')
          .attr('stroke', '#aaa');

        lineGroup
          .append('path')
          .attr('d', function(path, idx) {
            var d = [];
            _.each(path.parents, function(parentId) {
              var p = tree[parentId];
              d.push({x: path.column * xGap + xGap, y: path.id * yGap + yGap});
              // TODO: Add middle points
              d.push({x: p.column * xGap + xGap, y: p.id * yGap + yGap});
            });
            return lineFunction(d)
          })
          .attr('stroke-width', 2)
          .attr('fill', 'none')
          .attr('stroke', '#5aa1be')
          .on('click', function(a,b,c,d) {
            console.log(a,b,c,d);
          });

        if (mode == 'commits') {
          lineGroup.selectAll('dummyCircle')
            .data(function(d, i) { return _.range(cols); })
            .enter()
            .append('circle')
              .attr('r', radius)
              .attr('fill', 'none')
              .attr('stroke', function(a,b,c) {
                if (tree[c].column == a) {
                  return '#000';
                }
                return '#ddd';
              })
              .attr('fill', function(a,b,c) {
                if (tree[c].column == a) {
                  return '#0f0';
                }
                return '#fff';
              })
              .attr('cx', function(c) {
                return c * xGap + xGap;
              })
              .attr('cy', function(c, i, a) { return a * yGap + yGap })
              .on('mouseenter', function() {
                d3.select(this).attr('fill', '#f00');
              })
              .on('mouseleave', function(a,b,c) {
                d3.select(this).attr('fill', function() {
                  return tree[c].column == a ? '#0f0' : '#fff' ;
                });
              })
              .on('click', function(a,b,c) {
                tree[c].column = a;
                render();
              });
        } else {
          lineGroup.selectAll('dummyCircle')
            .data(function(d, i) { return _.range(cols); })
            .enter()
            .append('circle')
              .attr('r', function(a,b,c) {
                if (tree[c].column == a) {
                  return radius;
                } else {
                  return 3;
                }
              })
              .attr('fill', 'none')
              .attr('stroke', function(a,b,c) {
                if (tree[c].column == a) {
                  return '#000';
                }
                return '#ddd';
              })
              .attr('fill', function(a,b,c) {
                if (tree[c].column == a) {
                  return '#0f0';
                }
                return '#aaa';
              })
              .attr('cx', function(c) {
                return c * xGap + xGap;
              })
              .attr('cy', function(c, i, a) { return a * yGap + yGap })
              .on('mousedown', function(a,b,c) {
                firstCommit = c;
              })
              .on('mouseup', function(colIndex, colIndex, rowIndex) {
                if (tree[rowIndex].column != colIndex) {
                  console.log('...CALISS');
                }
                if (firstCommit > rowIndex) {
                  firstCommit = [rowIndex, rowIndex = firstCommit][0]; // swap vars
                }
                if (!_.contains(tree[firstCommit].parents, rowIndex)) {
                  tree[firstCommit].parents.push(rowIndex.toString());
                  render();
                }
              });
        }

        generateTestsFile();

        var output = _.map(tree, function(el) { return _.pick(el, ['id', 'parents']); });
        $('#out').val(JSON.stringify(output, null, 2));
      };

      var generateTestsFile = function() {
        var testName = 'Test1';
        var out = '';
        out += 'func ' + testName + '(t *testing.T) {\n';

        out += '	// Initial input\n';
        out += '	inputNodes := make([]map[string]interface{}, 0)\n';
        _.each(tree, function(node) {
          var p = _.map(node.parents, function(el) { return '"' + el + '"'; }).join(',');
          out += '	inputNodes = append(inputNodes, map[string]interface{}{"id": "' + node.id + '", "parents": []string{' + p + '}})\n';
        });

        out += '\n	out, _ := buildTree(inputNodes, customColors)\n\n';

        out += '	// Expected output\n';
        var expectedColumns = _.pluck(tree, 'column').join(', ');
        out += '	expectedColumns := []int{' + expectedColumns + '}\n\n';

        out += '	expectedPaths := []map[string]Path{\n';
        _.each(tree, function(node) {
          out += '		map[string]Path{\n';
          _.each(node.parents, function(parentId) {
            var parentNode = tree[parentId];
            out += '			"' + parentId + '": Path{"' + parentId + '", []Point{Point{' + node.column + ', ' + node.id + ', 0}, Point{' + parentNode.column + ', ' + parentNode.id + ', 0}}, "nocolor"},\n';
          });
          out += '		},\n';
        });
        out += '	}\n\n';

        out += '	// Validation\n';
        out += '	validateColumns(t, expectedColumns, out)\n';
        out += '	validatePaths(t, expectedPaths, out)\n';
        out += '	validateColors(t, expectedPaths, out)\n';
        out += '}';

        $('#tests').val(out);

        /**
        func Test1(t *testing.T) {
          // Initial input
          inputNodes := make([]InputNode, 0)
          inputNodes = append(inputNodes, InputNode{"1", []string{"2"}})
          inputNodes = append(inputNodes, InputNode{"2", []string{"3"}})
          inputNodes = append(inputNodes, InputNode{"3", []string{}})

          out, _ := buildTree(inputNodes, customColors)

          // Expected output
          expectedColumns := []int{0, 0, 0}

          expectedPaths := []map[string]Path{
            map[string]Path{
              "2": Path{"2", []Point{Point{0, 0, 0}, Point{0, 1, 0}}, "color1"},
            },
            map[string]Path{
              "3": Path{"3", []Point{Point{0, 1, 0}, Point{0, 2, 0}}, "color1"},
            },
          }

          // Validation
          validateColumns(t, expectedColumns, out)
          validatePaths(t, expectedPaths, out)
          validateColors(t, expectedPaths, out)
        }
        **/

      };

      render();
    </script>
  </body>
</html>
